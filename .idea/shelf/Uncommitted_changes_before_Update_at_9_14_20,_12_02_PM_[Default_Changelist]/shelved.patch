Index: models/ResNet.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import torchvision\nimport torch.nn as nn\nfrom torch.nn import functional as F\nimport torch\n\nclass ResNet50(nn.Module):\n    def __init__(self,num_classes,loss={'softmax'},training=False,**kwargs):\n        super(ResNet50,self).__init__()\n        resnet50=torchvision.models.resnet50(pretrained=True)\n        self.base=nn.Sequential(*list(resnet50.children())[:-2])\n        self.classfier=nn.Linear(2048,num_classes)\n        self.training=training\n        pass\n    def forward(self,x):\n        x= self.base(x) #32*2048*8*4\n        x=F.avg_pool2d(x,x.size()[2:])\n        f=x.view(x.size(0),-1)\n        if not self.training:\n            return f\n        y=self.classfier(f)\n        return y\n\n\nif __name__=='__main__':\n    model=ResNet50(num_classes=751,training=True)\n    input=torch.rand(32,3,256,128)\n    output=model(input)\n    pass
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- models/ResNet.py	(revision af3eb3e4268796d6f695c4e20ee5a5016237c6b9)
+++ models/ResNet.py	(date 1600074432115)
@@ -23,6 +23,6 @@
 
 if __name__=='__main__':
     model=ResNet50(num_classes=751,training=True)
-    input=torch.rand(32,3,256,128)
+    input=torch.rand(1,3,256,128)
     output=model(input)
     pass
\ No newline at end of file
Index: train.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import print_function, absolute_import\nimport os\nimport sys\nimport time\nimport datetime\nimport argparse\nimport os.path as osp\nimport numpy as np\nimport torch\nimport torch.nn as nn\nimport torch.backends.cudnn as cudnn\nfrom torch.utils.data import DataLoader\nfrom torch.optim import lr_scheduler\nimport argparse\nimport sys\nfrom utils import *\nimport mydataset_manager\nfrom dataset_loader import ImageDataset\nfrom ResNet import ResNet50\nimport torchvision.transforms as T\n\nparser = argparse.ArgumentParser(description='Train image model with center loss')\n\nparser.add_argument('--start-epoch', default=0, type=int,\n                    help=\"manual epoch number (useful on restarts)\")\n\nparser.add_argument('--print-freq', type=int, default=10, help=\"print frequency\")\nparser.add_argument('--seed', type=int, default=1, help=\"manual seed\")\nparser.add_argument('--resume', type=str, default='', metavar='PATH')\nparser.add_argument('--evaluate', action='store_true', help=\"evaluation only\")\nparser.add_argument('--eval-step', type=int, default=-1,\n                    help=\"run evaluation for every N epochs (set to -1 to test after training)\")\nparser.add_argument('--start-eval', type=int, default=0, help=\"start to evaluate after specific epoch\")\nparser.add_argument('--save-dir', type=str, default='log')\nparser.add_argument('--use-cpu', action='store_true', help=\"use cpu\")\nparser.add_argument('--gpu-devices', default='0', type=str, help='gpu device ids for CUDA_VISIBLE_DEVICES')\nargs = parser.parse_args()\ndef main():\n    #config\n    config=get_config('/root/proj/JMSreid/config/config.yaml')\n    train_epoch=config['train_epoch']\n\n    #gpu_setting\n    use_gpu=torch.cuda.is_available()\n    pin_memory=True if use_gpu else False\n    if use_gpu:\n        print(\"Currently using GPU {}\".format(args.gpu_devices))\n        cudnn.benchmark = True\n        torch.cuda.manual_seed_all(args.seed)\n    else:\n        print(\"Currently using CPU (GPU is highly recommended)\")\n    #logs\n    if not args.evaluate:\n        sys.stdout = Logger(osp.join(args.save_dir, 'log_train.txt'))\n    else:\n        sys.stdout = Logger(osp.join(args.save_dir, 'log_test.txt'))\n    print(\"==========\\nArgs:{}\\n==========\".format(args))\n\n    #dataset 3 loader\n    dataset=mydataset_manager.Market1501(root=config['dataset_root'])\n    transform_train = T.Compose([\n        T.Resize((config['height'], config['width']),interpolation=3),\n        T.RandomHorizontalFlip(),\n        T.ToTensor(),\n        T.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),\n    ])\n\n    transform_test = T.Compose([\n        T.Resize((config['height'], config['width']),interpolation=3),\n        T.ToTensor(),\n        T.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),\n    ])\n    train_loader=DataLoader(\n        ImageDataset(dataset.train,transformer=transform_train),\n        batch_size=config['train_batch'],\n        pin_memory=pin_memory,\n        shuffle=True,\n        num_workers=config['workers'],\n        drop_last=True\n    )\n    query_loader=DataLoader(\n        ImageDataset(dataset.query,transformer=transform_test),\n        batch_size=config['test_batch'],\n        pin_memory=pin_memory,\n        shuffle=False,\n        num_workers=config['workers'],\n        drop_last=False\n    )\n    gallery_loader=DataLoader(\n        ImageDataset(dataset.test, transformer=transform_test),\n        batch_size=config['test_batch'],\n        pin_memory=pin_memory,\n        shuffle=False,\n        num_workers=config['workers'],\n        drop_last=False\n    )\n    print(\"Initializing model: {}\".format(config['arch']))\n    if config['arch']=='ResNet50':\n        model = ResNet50(num_classes=dataset.train_num_pids,training=True,loss='softmax')\n    print(\"Model size: {:.5f}M\".format(sum(p.numel() for p in model.parameters())/1000000.0))\n\n    #criterion\n    criterion=nn.CrossEntropyLoss()\n    optimizer=torch.optim.Adam(model.parameters(),lr=config['lr'],weight_decay=config['weight_decay'])\n    if config['step_size'] > 0:\n        scheduler = lr_scheduler.StepLR(optimizer, step_size=config['step_size'], gamma=config['gamma'])\n\n    start_epoch = args.start_epoch\n    if args.resume:\n        print(\"Loading checkpoint from '{}'\".format(args.resume))\n        checkpoint = torch.load(args.resume)\n        model.load_state_dict(checkpoint['state_dict'])\n        start_epoch = checkpoint['epoch']\n\n    if use_gpu:\n        model = nn.DataParallel(model).cuda()\n\n    if args.evaluate:\n        print(\"Evaluate only\")\n        test(model, query_loader, gallery_loader, use_gpu)\n        return 0\n\n    start_time = time.time()\n    train_time = 0\n    best_rank1 = -np.inf\n    best_epoch = 0\n    print(\"==> Start training\")\n\n    for epoch in range(start_epoch,train_epoch):\n        start_train_time = time.time()\n        train(epoch,model,criterion,optimizer,train_loader,use_gpu)\n        if config['step_size']: scheduler.step()\ndef train(epoch,model,criterion,optimizer,train_loader,use_gpu):\n    for batch_id,(imgs,pids,_) in enumerate(train_loader):\n        if use_gpu:\n            imgs,pids=imgs.cuda(),pids.cuda()\n        prediction =model(imgs)\n        loss =criterion(prediction,pids)\n        optimizer.zero_grad()\n        loss.backward()\n        optimizer.step()\n        print(epoch,batch_id,loss)\n    pass\n\ndef test():\n    pass\n\n\n\n\n\n\n\n\n\n\n\nif __name__=='__main__':\n    main()
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- train.py	(revision af3eb3e4268796d6f695c4e20ee5a5016237c6b9)
+++ train.py	(date 1600075079639)
@@ -136,6 +136,7 @@
             imgs,pids=imgs.cuda(),pids.cuda()
         prediction =model(imgs)
         loss =criterion(prediction,pids)
+        print(prediction,'',pids,'',loss)
         optimizer.zero_grad()
         loss.backward()
         optimizer.step()
